const mongoose = require('mongoose');
const mongoosePaginate = require('mongoose-paginate-v2');

const inwardItemSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.Mixed, // Can be ObjectId or String
    required: true
  },
  productName: {
    type: String,
    required: true
  },
  orderedQuantity: {
    type: Number,
    required: true,
    min: 0
  },
  receivedQuantity: {
    type: Number,
    required: true,
    min: 0
  },
  unitCost: {
    type: Number,
    required: true,
    min: 0
  },
  total: {
    type: Number,
    required: true,
    min: 0
  },
  batchNumber: {
    type: String,
    required: true,
    trim: true
  },
  manufacturingDate: {
    type: Date,
    required: true
  },
  expiryDate: {
    type: Date
  },
  notes: {
    type: String,
    trim: true
  }
});

const inwardSchema = new mongoose.Schema({
  grnNumber: {
    type: String,
    required: false, // Will be auto-generated by pre-save hook
    unique: true,
    sparse: true // Allow null/undefined values for unique index
  },
  supplier: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Supplier',
    required: true
  },
  purchaseOrder: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Purchase',
    default: null
  },
  items: [inwardItemSchema],
  totalAmount: {
    type: Number,
    required: true,
    min: 0
  },
  status: {
    type: String,
    enum: ['draft', 'pending', 'approved', 'rejected', 'completed', 'cancelled'],
    default: 'draft'
  },
  receivedDate: {
    type: Date,
    default: Date.now
  },
  invoiceNumber: {
    type: String,
    trim: true
  },
  invoiceDate: {
    type: Date
  },
  deliveryChallanNumber: {
    type: String,
    trim: true
  },
  vehicleNumber: {
    type: String,
    trim: true
  },
  notes: {
    type: String,
    trim: true
  },
  qualityCheckStatus: {
    type: String,
    enum: ['pending', 'passed', 'failed', 'partial'],
    default: 'pending'
  },
  qualityCheckNotes: {
    type: String,
    trim: true
  },
  inventoryAdded: {
    type: Boolean,
    default: false
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  approvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  approvalDate: {
    type: Date
  },
  rejectionReason: {
    type: String,
    trim: true
  }
}, {
  timestamps: true
});

// Add pagination plugin
inwardSchema.plugin(mongoosePaginate);

// Add indexes for better query performance
inwardSchema.index({ supplier: 1, status: 1 });
inwardSchema.index({ receivedDate: -1 });
inwardSchema.index({ status: 1, createdAt: -1 });

// Create a counter collection for GRN numbers
const Counter = mongoose.models.Counter || 
  mongoose.model('Counter', new mongoose.Schema({
    _id: { type: String, required: true },
    seq: { type: Number, default: 0 }
  }));

// Generate GRN number before validation
inwardSchema.pre('validate', async function(next) {
  if (this.isNew && !this.grnNumber) {
    try {
      console.log('ðŸ”¢ Generating GRN number...');
      const today = new Date();
      const year = today.getFullYear();
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const day = String(today.getDate()).padStart(2, '0');
      const dateStr = `${year}${month}${day}`;
      
      // Find and increment the counter for today's date
      const counter = await Counter.findByIdAndUpdate(
        { _id: `grn_${dateStr}` },
        { $inc: { seq: 1 } },
        { new: true, upsert: true, setDefaultsOnInsert: true }
      );
      
      this.grnNumber = `GRN-${dateStr}-${String(counter.seq).padStart(4, '0')}`;
      console.log('âœ… Generated GRN number:', this.grnNumber);
    } catch (error) {
      console.error('âŒ Error generating GRN number:', error);
      return next(error);
    }
  }
  next();
});

// Add error handling for duplicate GRN numbers
inwardSchema.post('save', function(error, doc, next) {
  if (error.name === 'MongoServerError' && error.code === 11000) {
    // If it's a duplicate key error for grnNumber
    if (error.keyPattern && error.keyPattern.grnNumber) {
      // Remove the grnNumber and save again (will generate a new one)
      doc.grnNumber = undefined;
      return doc.save().then(() => next()).catch(next);
    }
  }
  next(error);
});

// Calculate item totals and total amount before saving
inwardSchema.pre('save', function(next) {
  if (this.isModified('items')) {
    // Calculate individual item totals
    this.items.forEach(item => {
      item.total = item.receivedQuantity * item.unitCost;
    });

    // Calculate total amount
    this.totalAmount = this.items.reduce((total, item) => total + item.total, 0);
  }
  next();
});

// Virtual for completion percentage
inwardSchema.virtual('completionPercentage').get(function() {
  if (!this.items || this.items.length === 0) return 0;

  const totalItems = this.items.length;
  const completedItems = this.items.filter(item =>
    item.receivedQuantity >= item.orderedQuantity
  ).length;

  return totalItems > 0 ? Math.round((completedItems / totalItems) * 100) : 0;
});

// Virtual for pending items
inwardSchema.virtual('pendingItems').get(function() {
  return this.items.filter(item => item.receivedQuantity < item.orderedQuantity);
});

// Instance method to check if inward can be modified
inwardSchema.methods.canBeModified = function() {
  return !['approved', 'completed', 'cancelled'].includes(this.status);
};

// Instance method to check if inward can be approved
inwardSchema.methods.canBeApproved = function() {
  return this.status === 'pending' || this.status === 'draft';
};

// Static method to get inwards by status
inwardSchema.statics.findByStatus = function(status, options = {}) {
  return this.find({ status }, null, options);
};

// Static method to get inwards by date range
inwardSchema.statics.findByDateRange = function(startDate, endDate, options = {}) {
  return this.find({
    receivedDate: {
      $gte: startDate,
      $lte: endDate
    }
  }, null, options);
};

// Ensure virtual fields are serialized
inwardSchema.set('toJSON', { virtuals: true });
inwardSchema.set('toObject', { virtuals: true });

module.exports = mongoose.model('Inward', inwardSchema);
